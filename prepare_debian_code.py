"""
Prepare Debian Code Corpus — Extract code from Debian source packages
=====================================================================
Downloads source packages from Debian stable's main repo (all DFSG-free),
extracts code files across all languages, and outputs a training corpus.

Every package in Debian main is DFSG-vetted, making this suitable for
inclusion in Debian main repos without license concerns.

Prerequisites (checked automatically on startup):
  - Debian-based system (Debian, Ubuntu, etc.)
  - deb-src lines enabled in /etc/apt/sources.list (for apt-get source)
  - dpkg-dev package installed (provides dpkg-source)

To enable deb-src on Debian:
    sudo sed -i 's/^Types: deb$/Types: deb deb-src/' /etc/apt/sources.list.d/debian.sources
    sudo apt-get update

To enable deb-src on Ubuntu:
    sudo sed -i '/^#\\s*deb-src/s/^#\\s*//' /etc/apt/sources.list
    sudo apt-get update

Install dpkg-dev if missing:
    sudo apt-get install dpkg-dev

Output:
  - data/debian_code.jsonl      (~2-3GB code corpus, ~300k+ source files)

Usage:
    python prepare_debian_code.py
    python prepare_debian_code.py --packages 50       # limit package count
    python prepare_debian_code.py --target-gb 2.0     # smaller target
    python prepare_debian_code.py --skip-download      # reprocess existing downloads
"""

import os
import sys
import json
import subprocess
import shutil
import datetime
import argparse
import tempfile
from pathlib import Path
from collections import defaultdict

# ---------------------------------------------------------------------------
# Config
# ---------------------------------------------------------------------------

OUTPUT_PATH = "data/debian_code.jsonl"
WORK_DIR = "data/debian_code_work"

TARGET_SIZE_GB = 3.0
MAX_FILE_SIZE = 100_000   # bytes — skip huge generated/data files
MIN_FILE_SIZE = 50        # bytes — skip trivially small files
DOWNLOAD_TIMEOUT = 600    # seconds per package download
EXTRACT_TIMEOUT = 300     # seconds per package extraction

# Code file extensions
CODE_EXTENSIONS = {
    # Systems programming
    '.c', '.h', '.cpp', '.cc', '.cxx', '.hpp', '.hxx', '.hh',
    # Python
    '.py', '.pyx', '.pxd',
    # Java / JVM
    '.java', '.scala', '.kt', '.kts', '.groovy',
    # JavaScript / TypeScript
    '.js', '.ts', '.jsx', '.tsx', '.mjs', '.cjs',
    # Ruby
    '.rb',
    # Go
    '.go',
    # Rust
    '.rs',
    # Perl
    '.pl', '.pm', '.t',
    # Shell
    '.sh', '.bash', '.zsh',
    # Lua
    '.lua',
    # Haskell / OCaml / Functional
    '.hs', '.lhs', '.ml', '.mli',
    # Lisp / Scheme
    '.el', '.lisp', '.cl', '.scm', '.ss', '.rkt',
    # PHP
    '.php',
    # Swift / Objective-C
    '.swift', '.m', '.mm',
    # R
    '.r', '.R',
    # SQL
    '.sql',
    # Build files
    '.cmake', '.mk',
    # Web
    '.css',
    # Config (code-like)
    '.toml', '.yaml', '.yml',
}

# Files matched by name (no extension matching needed)
CODE_FILENAMES = {
    'Makefile', 'GNUmakefile', 'CMakeLists.txt', 'Dockerfile',
    'Rakefile', 'Gemfile', 'SConstruct', 'SConscript',
    'configure.ac', 'configure.in', 'meson.build',
    'BUILD', 'WORKSPACE', 'Justfile',
}

# Extension → language mapping
EXT_TO_LANG = {
    '.c': 'c', '.h': 'c', '.cpp': 'cpp', '.cc': 'cpp', '.cxx': 'cpp',
    '.hpp': 'cpp', '.hxx': 'cpp', '.hh': 'cpp',
    '.py': 'python', '.pyx': 'python', '.pxd': 'python',
    '.java': 'java', '.scala': 'scala', '.kt': 'kotlin', '.groovy': 'groovy',
    '.js': 'javascript', '.ts': 'typescript', '.jsx': 'javascript',
    '.tsx': 'typescript', '.mjs': 'javascript', '.cjs': 'javascript',
    '.rb': 'ruby', '.go': 'go', '.rs': 'rust',
    '.pl': 'perl', '.pm': 'perl', '.t': 'perl',
    '.sh': 'shell', '.bash': 'shell', '.zsh': 'shell',
    '.lua': 'lua', '.hs': 'haskell', '.lhs': 'haskell',
    '.ml': 'ocaml', '.mli': 'ocaml',
    '.el': 'elisp', '.lisp': 'lisp', '.cl': 'lisp',
    '.scm': 'scheme', '.ss': 'scheme', '.rkt': 'racket',
    '.php': 'php', '.swift': 'swift', '.m': 'objective-c', '.mm': 'objective-c',
    '.r': 'r', '.R': 'r', '.sql': 'sql',
    '.css': 'css', '.cmake': 'cmake', '.mk': 'make',
    '.toml': 'toml', '.yaml': 'yaml', '.yml': 'yaml',
    '.kts': 'kotlin',
}

# Skip paths containing these segments
SKIP_PATH_SEGMENTS = {
    '.git', 'debian', '.svn', '.hg', '__pycache__',
    'node_modules', '.tox', '.eggs', 'vendor',
}

# Generated file markers (in first 5 lines)
GENERATED_MARKERS = [
    'DO NOT EDIT', 'do not edit', 'Do not edit',
    'Generated by', 'generated by', 'GENERATED BY',
    'AUTO-GENERATED', 'auto-generated', 'Auto-generated',
    'This file is automatically generated',
    'Machine generated', 'machine generated',
    'Code generated by', 'code generated by',
]

# Curated package list — diverse, popular, multi-language
# Each package must be in Debian main (DFSG-free)
PACKAGES = [
    # Core system (C)
    'coreutils', 'util-linux', 'bash', 'dash', 'zsh', 'procps',
    'findutils', 'grep', 'sed', 'gawk', 'diffutils', 'patch',
    'tar', 'gzip', 'bzip2', 'xz-utils',
    'shadow', 'login', 'passwd',
    # Networking (C)
    'curl', 'wget', 'openssh', 'openssl', 'iproute2',
    'iptables', 'nftables', 'bind9', 'ntp', 'rsync',
    'socat', 'netcat-openbsd',
    # Servers (C, mixed)
    'nginx', 'apache2', 'lighttpd',
    'postgresql-16', 'sqlite3', 'mariadb-server',
    'redis', 'memcached',
    'postfix', 'dovecot',
    'samba', 'nfs-utils',
    # Development tools (C, C++)
    'gcc-14', 'binutils', 'make', 'cmake', 'meson', 'ninja-build',
    'gdb', 'strace', 'ltrace', 'valgrind',
    'git', 'subversion', 'mercurial',
    'flex', 'bison',
    # Libraries (C)
    'glibc', 'zlib', 'libpng', 'libjpeg-turbo', 'libxml2',
    'libffi', 'pcre2', 'expat', 'gmp', 'mpfr',
    'ncurses', 'readline',
    # System services (C, mixed)
    'systemd', 'dbus', 'udev',
    'pam', 'polkit',
    'logrotate', 'cron',
    # Text processing (C, mixed)
    'vim', 'nano', 'less', 'file',
    'groff', 'texinfo',
    # Media (C, C++)
    'ffmpeg', 'libav', 'sox', 'imagemagick',
    'poppler', 'ghostscript',
    # Python ecosystem
    'python3.12', 'python3-pip', 'python3-setuptools',
    'python3-requests', 'python3-flask', 'python3-django',
    'python3-numpy', 'python3-cryptography',
    'python3-yaml', 'python3-jinja2',
    'python3-pytest', 'python3-sphinx',
    'python3-click', 'python3-httpx',
    'python3-sqlalchemy',
    'python3-attr', 'python3-pydantic',
    'black', 'pylint', 'mypy',
    # Perl
    'perl', 'libwww-perl', 'libdbi-perl',
    'libxml-parser-perl', 'libtext-csv-perl',
    # Ruby
    'ruby', 'ruby-rack', 'ruby-nokogiri',
    # Go
    'golang-1.23', 'golang-github-spf13-cobra',
    'golang-github-sirupsen-logrus',
    # Rust
    'rustc', 'cargo',
    'rust-regex', 'rust-serde', 'rust-tokio',
    'fd-find', 'ripgrep', 'bat',
    # Java
    'openjdk-21-jdk-headless', 'ant', 'maven',
    'gradle',
    # JavaScript / Node
    'nodejs',
    # Haskell
    'ghc', 'pandoc',
    # Lua
    'lua5.4', 'luarocks',
    # PHP
    'php8.3',
    # Desktop (C, C++)
    'xorg-server', 'mesa',
    'gtk+3.0', 'qt6-base',
    'alsa-lib', 'pulseaudio', 'pipewire',
    # Compression / Archiving
    'p7zip', 'unzip', 'libarchive',
    'lz4', 'zstd',
    # Crypto / Security
    'gnupg2', 'libgcrypt20', 'libsodium',
    'ca-certificates', 'certbot',
    # Containers / Virtualization
    'podman', 'lxc', 'qemu',
    # Monitoring / Admin
    'htop', 'iotop', 'sysstat', 'dstat',
    'tmux', 'screen',
    # Misc tools
    'jq', 'fzf', 'tree', 'parallel',
    'units', 'bc', 'dc',
    # Scientific
    'octave', 'r-base',
    # Emacs
    'emacs', 'elpa-magit',
    # Fonts / i18n (some have code)
    'fontconfig', 'icu',
    # Misc libraries
    'boost', 'eigen3', 'lapack',
    'protobuf', 'flatbuffers', 'capnproto',
    'libevent', 'libev', 'libuv',
]


def log(msg):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {msg}", flush=True)


# ---------------------------------------------------------------------------
# File detection and filtering
# ---------------------------------------------------------------------------

def is_code_file(filepath):
    """Check if a file should be included based on extension or name."""
    name = os.path.basename(filepath)
    if name in CODE_FILENAMES:
        return True
    _, ext = os.path.splitext(name)
    return ext.lower() in CODE_EXTENSIONS or ext in CODE_EXTENSIONS


def detect_language(filepath):
    """Detect programming language from file extension or name."""
    name = os.path.basename(filepath)
    if name in ('Makefile', 'GNUmakefile'):
        return 'make'
    if name == 'CMakeLists.txt':
        return 'cmake'
    if name == 'Dockerfile':
        return 'dockerfile'
    if name in ('Rakefile', 'Gemfile'):
        return 'ruby'
    if name in ('SConstruct', 'SConscript'):
        return 'python'
    if name in ('configure.ac', 'configure.in'):
        return 'autoconf'
    if name == 'meson.build':
        return 'meson'
    if name == 'Justfile':
        return 'just'

    _, ext = os.path.splitext(name)
    return EXT_TO_LANG.get(ext.lower(), EXT_TO_LANG.get(ext, 'unknown'))


def is_binary(filepath, sample_size=512):
    """Check if a file is binary by looking for null bytes."""
    try:
        with open(filepath, 'rb') as f:
            chunk = f.read(sample_size)
        return b'\x00' in chunk
    except (OSError, IOError):
        return True


def is_generated(content, check_lines=5):
    """Check if file content looks auto-generated."""
    lines = content.split('\n', check_lines)[:check_lines]
    header = '\n'.join(lines)
    return any(marker in header for marker in GENERATED_MARKERS)


def should_skip_path(filepath):
    """Check if file path contains segments we should skip."""
    parts = Path(filepath).parts
    return any(seg in SKIP_PATH_SEGMENTS for seg in parts)


# ---------------------------------------------------------------------------
# Source package operations
# ---------------------------------------------------------------------------

def download_source(package, work_dir):
    """Download a source package using apt-get source --download-only."""
    try:
        result = subprocess.run(
            ['apt-get', 'source', '--download-only', package],
            cwd=work_dir,
            capture_output=True, text=True,
            timeout=DOWNLOAD_TIMEOUT,
        )
        if result.returncode != 0:
            # Try without --download-only as fallback
            result = subprocess.run(
                ['apt-get', 'source', package],
                cwd=work_dir,
                capture_output=True, text=True,
                timeout=DOWNLOAD_TIMEOUT,
            )
            if result.returncode != 0:
                return None, result.stderr.strip().split('\n')[-1] if result.stderr else "unknown error"
        return work_dir, None
    except subprocess.TimeoutExpired:
        return None, "timeout"
    except Exception as e:
        return None, str(e)


def find_and_extract_dsc(work_dir):
    """Find .dsc files and extract them with dpkg-source."""
    extracted_dirs = []
    # Record existing directories before extraction
    existing_dirs = set(
        e for e in os.listdir(work_dir)
        if os.path.isdir(os.path.join(work_dir, e))
    )
    for fname in os.listdir(work_dir):
        if fname.endswith('.dsc'):
            # Use absolute path for dpkg-source
            dsc_path = os.path.abspath(os.path.join(work_dir, fname))
            try:
                result = subprocess.run(
                    ['dpkg-source', '-x', '--no-check', dsc_path],
                    cwd=work_dir,
                    capture_output=True, text=True,
                    timeout=EXTRACT_TIMEOUT,
                )
                if result.returncode == 0:
                    # Find newly created directories
                    for entry in os.listdir(work_dir):
                        entry_path = os.path.join(work_dir, entry)
                        if (os.path.isdir(entry_path)
                                and entry not in existing_dirs):
                            extracted_dirs.append(entry_path)
            except (subprocess.TimeoutExpired, Exception):
                pass
    return extracted_dirs


def extract_code_files(pkg_dir, package_name):
    """Walk an extracted package directory and yield code file contents."""
    for root, dirs, files in os.walk(pkg_dir, followlinks=False):
        # Prune directories we don't want to descend into
        dirs[:] = [d for d in dirs if d not in SKIP_PATH_SEGMENTS]

        for fname in files:
            filepath = os.path.join(root, fname)

            if not is_code_file(filepath):
                continue

            rel_path = os.path.relpath(filepath, pkg_dir)

            if should_skip_path(rel_path):
                continue

            try:
                file_size = os.path.getsize(filepath)
            except OSError:
                continue

            if file_size < MIN_FILE_SIZE or file_size > MAX_FILE_SIZE:
                continue

            if is_binary(filepath):
                continue

            try:
                with open(filepath, encoding='utf-8', errors='replace') as f:
                    content = f.read()
            except (OSError, IOError):
                continue

            if not content.strip():
                continue

            if is_generated(content):
                continue

            lang = detect_language(filepath)
            yield rel_path, lang, content


# ---------------------------------------------------------------------------
# Prerequisites check
# ---------------------------------------------------------------------------

def check_prerequisites():
    """Verify system can download and extract Debian source packages."""
    errors = []

    # Check for dpkg-source
    if shutil.which('dpkg-source') is None:
        errors.append(
            "dpkg-source not found. Install with:\n"
            "    sudo apt-get install dpkg-dev"
        )

    # Check for apt-get
    if shutil.which('apt-get') is None:
        errors.append(
            "apt-get not found. This script requires a Debian-based system."
        )

    # Check for deb-src in sources
    has_deb_src = False
    sources_paths = ['/etc/apt/sources.list']
    src_d = Path('/etc/apt/sources.list.d/')
    if src_d.exists():
        sources_paths.extend(src_d.glob('*.list'))
        sources_paths.extend(src_d.glob('*.sources'))
    for src_path in sources_paths:
        try:
            content = Path(src_path).read_text()
            if 'deb-src' in content or 'Types: deb deb-src' in content:
                has_deb_src = True
                break
        except (OSError, IOError):
            continue

    if not has_deb_src:
        # Try a real test — some systems use modern DEB822 format
        result = subprocess.run(
            ['apt-get', 'source', '--download-only', '--dry-run', 'coreutils'],
            capture_output=True, text=True, timeout=15,
        )
        if result.returncode == 0:
            has_deb_src = True

    if not has_deb_src:
        errors.append(
            "No deb-src sources found. Enable with:\n"
            "  Debian:  sudo sed -i 's/^Types: deb$/Types: deb deb-src/' "
            "/etc/apt/sources.list.d/debian.sources && sudo apt-get update\n"
            "  Ubuntu:  sudo sed -i '/^#\\s*deb-src/s/^#\\s*//' "
            "/etc/apt/sources.list && sudo apt-get update"
        )

    if errors:
        log("PREREQUISITES CHECK FAILED:")
        for e in errors:
            log(f"  {e}")
        sys.exit(1)

    log("Prerequisites OK: dpkg-source found, deb-src enabled")


# ---------------------------------------------------------------------------
# Main processing
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Prepare Debian Code Corpus for Training")
    parser.add_argument('--packages', type=int, default=len(PACKAGES),
                        help=f'Max packages to process (default: {len(PACKAGES)})')
    parser.add_argument('--target-gb', type=float, default=TARGET_SIZE_GB,
                        help=f'Target output size in GB (default: {TARGET_SIZE_GB})')
    parser.add_argument('--skip-download', action='store_true',
                        help='Skip downloading, reprocess existing extractions')
    parser.add_argument('--output', type=str, default=OUTPUT_PATH,
                        help=f'Output path (default: {OUTPUT_PATH})')
    args = parser.parse_args()

    target_bytes = int(args.target_gb * 1024 * 1024 * 1024)
    packages_to_process = PACKAGES[:args.packages]

    log("=" * 70)
    log("PREPARE DEBIAN CODE CORPUS")
    log("=" * 70)

    if not args.skip_download:
        check_prerequisites()

    log(f"Packages: {len(packages_to_process)}")
    log(f"Target size: {args.target_gb:.1f} GB")
    log(f"Output: {args.output}")

    os.makedirs(os.path.dirname(args.output) or '.', exist_ok=True)
    os.makedirs(WORK_DIR, exist_ok=True)

    # Stats tracking
    total_files = 0
    total_bytes = 0
    lang_counts = defaultdict(int)
    lang_bytes = defaultdict(int)
    pkg_succeeded = 0
    pkg_failed = 0
    pkg_skipped = 0

    with open(args.output, 'w') as out_f:
        for i, package in enumerate(packages_to_process):
            if total_bytes >= target_bytes:
                log(f"Reached target size ({total_bytes / 1e9:.2f} GB), stopping")
                break

            pct = (i / len(packages_to_process)) * 100
            log(f"[{i+1}/{len(packages_to_process)} {pct:.0f}%] "
                f"Processing {package}... "
                f"({total_files:,} files, {total_bytes / 1e9:.2f} GB so far)")

            # Use a temp directory per package to limit disk usage
            pkg_work_dir = os.path.join(WORK_DIR, package)
            os.makedirs(pkg_work_dir, exist_ok=True)

            try:
                if not args.skip_download:
                    _, err = download_source(package, pkg_work_dir)
                    if err:
                        log(f"  SKIP {package}: {err}")
                        pkg_failed += 1
                        continue

                # Find and extract .dsc files
                extracted = find_and_extract_dsc(pkg_work_dir)

                if not extracted:
                    # Maybe apt-get source already extracted it
                    # Check for directories in work dir
                    subdirs = [os.path.join(pkg_work_dir, d)
                               for d in os.listdir(pkg_work_dir)
                               if os.path.isdir(os.path.join(pkg_work_dir, d))]
                    if subdirs:
                        extracted = subdirs
                    else:
                        log(f"  SKIP {package}: no extracted source found")
                        pkg_skipped += 1
                        continue

                pkg_files = 0
                pkg_bytes_local = 0

                for pkg_dir in extracted:
                    pkg_name = os.path.basename(pkg_dir)
                    for rel_path, lang, content in extract_code_files(pkg_dir, package):
                        header = f"# File: {pkg_name}/{rel_path}\n# Language: {lang}\n"
                        text = header + content

                        entry = json.dumps({"text": text})
                        out_f.write(entry + "\n")

                        entry_bytes = len(entry.encode('utf-8'))
                        total_bytes += entry_bytes
                        total_files += 1
                        pkg_files += 1
                        pkg_bytes_local += entry_bytes
                        lang_counts[lang] += 1
                        lang_bytes[lang] += entry_bytes

                        if total_bytes >= target_bytes:
                            break

                    if total_bytes >= target_bytes:
                        break

                if pkg_files > 0:
                    log(f"  {package}: {pkg_files} files, "
                        f"{pkg_bytes_local / 1e6:.1f} MB")
                    pkg_succeeded += 1
                else:
                    log(f"  {package}: no code files found")
                    pkg_skipped += 1

            except Exception as e:
                log(f"  ERROR {package}: {e}")
                pkg_failed += 1
            finally:
                # Clean up extracted source to save disk space
                if not args.skip_download:
                    try:
                        shutil.rmtree(pkg_work_dir, ignore_errors=True)
                    except Exception:
                        pass

    # Summary
    log("")
    log("=" * 70)
    log("DEBIAN CODE CORPUS — SUMMARY")
    log("=" * 70)
    log(f"Packages: {pkg_succeeded} succeeded, {pkg_failed} failed, "
        f"{pkg_skipped} skipped")
    log(f"Total files: {total_files:,}")
    log(f"Total size: {total_bytes / 1e9:.2f} GB")
    log(f"Output: {args.output}")
    log("")
    log("Language distribution:")
    for lang, count in sorted(lang_counts.items(), key=lambda x: -x[1]):
        mb = lang_bytes[lang] / 1e6
        pct = lang_bytes[lang] / max(total_bytes, 1) * 100
        log(f"  {lang:20s}: {count:6,} files, {mb:8.1f} MB ({pct:.1f}%)")

    log("")
    log("All code sourced from Debian main — DFSG-free by definition.")
    log("=" * 70)


if __name__ == "__main__":
    main()
